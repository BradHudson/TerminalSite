'use strict';

var api = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get consent () { return consent; },
    get data () { return data; },
    get getConsent () { return getConsent; },
    get getData () { return getData; },
    get getUserId () { return getUserId; },
    get init () { return init; },
    get isNewUser () { return isNewUser; },
    get keys () { return keys; },
    get ready () { return ready; },
    get setConfig () { return setConfig; },
    get tag () { return tag; },
    get user () { return user; }
});

const isBool = (v) => typeof v == 'boolean';
const isRecord = (v) => !!v && typeof v == 'object' && !Array.isArray(v);
/**
 * This function validates user consent for a given provider and tag name.
 * It should be used in conjunction with `UserConsent`, not `ProvidersConfig`.
 */
const hasUserConsent = (consent, provider, tagName) => {
    var _a, _b;
    let allowed = false;
    if (isRecord(consent.consentChannel)) {
        allowed = isBool(consent.consentChannel.all)
            ? consent.consentChannel.all
            : false;
        if (provider in consent.consentChannel) {
            const providerSpecific = consent.consentChannel[provider];
            if (isBool(providerSpecific)) {
                allowed = providerSpecific;
            }
            else if (isRecord(providerSpecific)) {
                if ('all' in providerSpecific && isBool(providerSpecific.all)) {
                    allowed = providerSpecific.all;
                }
                if (tagName in providerSpecific && isBool(providerSpecific[tagName])) {
                    allowed = providerSpecific[tagName];
                }
            }
        }
    }
    if (allowed) {
        return true;
    }
    if (isRecord(consent.consentCategory) &&
        isRecord((_a = consent.consentSettings) === null || _a === void 0 ? void 0 : _a.channels)) {
        allowed = isBool(consent.consentCategory.all)
            ? consent.consentCategory.all
            : false;
        const category = (_b = Object.entries(consent.consentSettings.channels).find(([, value]) => {
            return value.includes(provider);
        })) === null || _b === void 0 ? void 0 : _b[0];
        if (category && consent.consentCategory[category]) {
            allowed = true;
        }
    }
    return allowed;
};
/**
 * This function validates provider allowance for a given provider and tag name.
 * It should not be used to validate `UserConsent`.
 */
const isProviderInstanceAllowed = (providersConfig, provider, tagName) => {
    if (!isRecord(providersConfig)) {
        return true;
    }
    if (provider in providersConfig) {
        const providerSpecific = providersConfig[provider];
        if (isBool(providerSpecific)) {
            return providerSpecific;
        }
        if (isRecord(providerSpecific)) {
            const tagKeys = Object.keys(providerSpecific).filter((k) => k != 'all');
            if (tagName in providerSpecific && isBool(providerSpecific[tagName])) {
                return providerSpecific[tagName];
            }
            return isBool(providerSpecific.all)
                ? providerSpecific.all
                : tagKeys.length == 0;
        }
    }
    const providerKeys = Object.keys(providersConfig).filter((k) => k != 'all');
    return isBool(providersConfig.all)
        ? providersConfig.all
        : providerKeys.length == 0;
};

const upsert = (map, key, update, createDefault) => {
    const currentValue = map.has(key)
        ? map.get(key)
        : createDefault();
    return map.set(key, update(currentValue));
};

const expand = (str) => str.split(',').flatMap((entry) => {
    if (!entry.includes('-')) {
        return entry;
    }
    const result = [];
    const [start, end] = entry.split('-').map(Number);
    for (let i = start; i <= end; i++) {
        result.push(i.toString());
    }
    return result;
});
/**
 * Exported from https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes
 *
 * In Dev Tools, select the `tbody` element containing the area codes and run the following code,
 * replacing the emdash character with a simple endash:
 *
 * ```ts
 * [...$0.querySelectorAll('td:first-child')]
 *   .filter(cell => cell.firstChild.nodeName != 'A')
 *   .map(cell => cell.textContent.trim()).join(',')
 * ```
 */
new Set([
    ...expand('200,211,221,222,230,232,233,235,237-238,241,243,244,245,247,255,257,258-259,261,265,266,271,273,274,275,277,278,280,282,283,285-287,288,290-299'),
    ...expand('300,311,322,324,327,328,333,335,338,342,344,348-349,353,355,356,357-359,362,366,369,370-379,381,382,383-384,387,388,389,390-399'),
    ...expand('400,411,420,421-422,426-427,428,429,433,439,444,446,449,451-454,455,456,457,459,460,461-462,465,466,467,471,476,477,481-483,485-486,487,488,489,490-499'),
    ...expand('511,532,535,536,537,538,542-543,545-547,549-550,552-554,555,556,558,560,565,568,569,576,578,583,589,590-599'),
    ...expand('611,621,624,625,627,632,633,634-635,637-638,642-643,644,648,652-654,655,663,665,666,668,673-676,677,679,685,686,687,688,690-699'),
    ...expand('711,722,723,729,733,735-736,739,741,744,745-746,748,749-751,752,755,756,759,761,764,766,768,776,777,783,788,789,790-799'),
    ...expand('811,821,822,823-824,827,834,836,841-842,846,851,852-853,871,874-875,879,880-887,889,890-899'),
    ...expand('911,921,922,923,924,926,927,932,933,935,942,944,946,950,953,955,957-958,960-969,974,975,976,977,981-982,987,988,990-999'),
]);

const isZeroPurchaseEvent = (payload) => {
    var _a;
    if (payload.eventName != 'Purchase') {
        return false;
    }
    const value = parseFloat((_a = payload.data) === null || _a === void 0 ? void 0 : _a.value);
    return value === 0;
};

/**
 * ISO-3166 2-leter country codes and their names
 * @see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
 */
const isoCountries = new Map([
    ['AD', 'Andorra'],
    ['AE', 'United Arab Emirates'],
    ['AF', 'Afghanistan'],
    ['AG', 'Antigua and Barbuda'],
    ['AI', 'Anguilla'],
    ['AL', 'Albania'],
    ['AM', 'Armenia'],
    ['AO', 'Angola'],
    ['AQ', 'Antarctica'],
    ['AR', 'Argentina'],
    ['AS', 'American Samoa'],
    ['AT', 'Austria'],
    ['AU', 'Australia'],
    ['AW', 'Aruba'],
    ['AX', 'Åland Islands'],
    ['AZ', 'Azerbaijan'],
    ['BA', 'Bosnia and Herzegovina'],
    ['BB', 'Barbados'],
    ['BD', 'Bangladesh'],
    ['BE', 'Belgium'],
    ['BF', 'Burkina Faso'],
    ['BG', 'Bulgaria'],
    ['BH', 'Bahrain'],
    ['BI', 'Burundi'],
    ['BJ', 'Benin'],
    ['BL', 'Saint Barthélemy'],
    ['BM', 'Bermuda'],
    ['BN', 'Brunei Darussalam'],
    ['BO', 'Bolivia, Plurinational State of'],
    ['BQ', 'Bonaire, Sint Eustatius and Saba'],
    ['BR', 'Brazil'],
    ['BS', 'Bahamas'],
    ['BT', 'Bhutan'],
    ['BV', 'Bouvet Island'],
    ['BW', 'Botswana'],
    ['BY', 'Belarus'],
    ['BZ', 'Belize'],
    ['CA', 'Canada'],
    ['CC', 'Cocos (Keeling) Islands'],
    ['CD', 'Congo, Democratic Republic of the'],
    ['CF', 'Central African Republic'],
    ['CG', 'Congo'],
    ['CH', 'Switzerland'],
    ['CI', "Côte d'Ivoire"],
    ['CK', 'Cook Islands'],
    ['CL', 'Chile'],
    ['CM', 'Cameroon'],
    ['CN', 'China'],
    ['CO', 'Colombia'],
    ['CR', 'Costa Rica'],
    ['CU', 'Cuba'],
    ['CV', 'Cabo Verde'],
    ['CW', 'Curaçao'],
    ['CX', 'Christmas Island'],
    ['CY', 'Cyprus'],
    ['CZ', 'Czechia'],
    ['DE', 'Germany'],
    ['DJ', 'Djibouti'],
    ['DK', 'Denmark'],
    ['DM', 'Dominica'],
    ['DO', 'Dominican Republic'],
    ['DZ', 'Algeria'],
    ['EC', 'Ecuador'],
    ['EE', 'Estonia'],
    ['EG', 'Egypt'],
    ['EH', 'Western Sahara'],
    ['ER', 'Eritrea'],
    ['ES', 'Spain'],
    ['ET', 'Ethiopia'],
    ['EU', 'European Union'],
    ['FI', 'Finland'],
    ['FJ', 'Fiji'],
    ['FK', 'Falkland Islands (Malvinas)'],
    ['FM', 'Micronesia, Federated States of'],
    ['FO', 'Faroe Islands'],
    ['FR', 'France'],
    ['GA', 'Gabon'],
    ['GB', 'United Kingdom of Great Britain and Northern Ireland'],
    ['GD', 'Grenada'],
    ['GE', 'Georgia'],
    ['GF', 'French Guiana'],
    ['GG', 'Guernsey'],
    ['GH', 'Ghana'],
    ['GI', 'Gibraltar'],
    ['GL', 'Greenland'],
    ['GM', 'Gambia'],
    ['GN', 'Guinea'],
    ['GP', 'Guadeloupe'],
    ['GQ', 'Equatorial Guinea'],
    ['GR', 'Greece'],
    ['GS', 'South Georgia and the South Sandwich Islands'],
    ['GT', 'Guatemala'],
    ['GU', 'Guam'],
    ['GW', 'Guinea-Bissau'],
    ['GY', 'Guyana'],
    ['HK', 'Hong Kong'],
    ['HM', 'Heard Island and McDonald Islands'],
    ['HN', 'Honduras'],
    ['HR', 'Croatia'],
    ['HT', 'Haiti'],
    ['HU', 'Hungary'],
    ['ID', 'Indonesia'],
    ['IE', 'Ireland'],
    ['IL', 'Israel'],
    ['IM', 'Isle of Man'],
    ['IN', 'India'],
    ['IO', 'British Indian Ocean Territory'],
    ['IQ', 'Iraq'],
    ['IR', 'Iran, Islamic Republic of'],
    ['IS', 'Iceland'],
    ['IT', 'Italy'],
    ['JE', 'Jersey'],
    ['JM', 'Jamaica'],
    ['JO', 'Jordan'],
    ['JP', 'Japan'],
    ['KE', 'Kenya'],
    ['KG', 'Kyrgyzstan'],
    ['KH', 'Cambodia'],
    ['KI', 'Kiribati'],
    ['KM', 'Comoros'],
    ['KN', 'Saint Kitts and Nevis'],
    ['KP', "Korea, Democratic People's Republic of"],
    ['KR', 'Korea, Republic of'],
    ['KW', 'Kuwait'],
    ['KY', 'Cayman Islands'],
    ['KZ', 'Kazakhstan'],
    ['LA', "Lao People's Democratic Republic"],
    ['LB', 'Lebanon'],
    ['LC', 'Saint Lucia'],
    ['LI', 'Liechtenstein'],
    ['LK', 'Sri Lanka'],
    ['LR', 'Liberia'],
    ['LS', 'Lesotho'],
    ['LT', 'Lithuania'],
    ['LU', 'Luxembourg'],
    ['LV', 'Latvia'],
    ['LY', 'Libya'],
    ['MA', 'Morocco'],
    ['MC', 'Monaco'],
    ['MD', 'Moldova, Republic of'],
    ['ME', 'Montenegro'],
    ['MF', 'Saint Martin (French part)'],
    ['MG', 'Madagascar'],
    ['MH', 'Marshall Islands'],
    ['MK', 'North Macedonia'],
    ['ML', 'Mali'],
    ['MM', 'Myanmar'],
    ['MN', 'Mongolia'],
    ['MO', 'Macao'],
    ['MP', 'Northern Mariana Islands'],
    ['MQ', 'Martinique'],
    ['MR', 'Mauritania'],
    ['MS', 'Montserrat'],
    ['MT', 'Malta'],
    ['MU', 'Mauritius'],
    ['MV', 'Maldives'],
    ['MW', 'Malawi'],
    ['MX', 'Mexico'],
    ['MY', 'Malaysia'],
    ['MZ', 'Mozambique'],
    ['NA', 'Namibia'],
    ['NC', 'New Caledonia'],
    ['NE', 'Niger'],
    ['NF', 'Norfolk Island'],
    ['NG', 'Nigeria'],
    ['NI', 'Nicaragua'],
    ['NL', 'Netherlands, Kingdom of the'],
    ['NO', 'Norway'],
    ['NP', 'Nepal'],
    ['NR', 'Nauru'],
    ['NU', 'Niue'],
    ['NZ', 'New Zealand'],
    ['OM', 'Oman'],
    ['PA', 'Panama'],
    ['PE', 'Peru'],
    ['PF', 'French Polynesia'],
    ['PG', 'Papua New Guinea'],
    ['PH', 'Philippines'],
    ['PK', 'Pakistan'],
    ['PL', 'Poland'],
    ['PM', 'Saint Pierre and Miquelon'],
    ['PN', 'Pitcairn'],
    ['PR', 'Puerto Rico'],
    ['PS', 'Palestine, State of'],
    ['PT', 'Portugal'],
    ['PW', 'Palau'],
    ['PY', 'Paraguay'],
    ['QA', 'Qatar'],
    ['RE', 'Réunion'],
    ['RO', 'Romania'],
    ['RS', 'Serbia'],
    ['RU', 'Russian Federation'],
    ['RW', 'Rwanda'],
    ['SA', 'Saudi Arabia'],
    ['SB', 'Solomon Islands'],
    ['SC', 'Seychelles'],
    ['SD', 'Sudan'],
    ['SE', 'Sweden'],
    ['SG', 'Singapore'],
    ['SH', 'Saint Helena, Ascension and Tristan da Cunha'],
    ['SI', 'Slovenia'],
    ['SJ', 'Svalbard and Jan Mayen'],
    ['SK', 'Slovakia'],
    ['SL', 'Sierra Leone'],
    ['SM', 'San Marino'],
    ['SN', 'Senegal'],
    ['SO', 'Somalia'],
    ['SR', 'Suriname'],
    ['SS', 'South Sudan'],
    ['ST', 'Sao Tome and Principe'],
    ['SV', 'El Salvador'],
    ['SX', 'Sint Maarten (Dutch part)'],
    ['SY', 'Syrian Arab Republic'],
    ['SZ', 'Eswatini'],
    ['TC', 'Turks and Caicos Islands'],
    ['TD', 'Chad'],
    ['TF', 'French Southern Territories'],
    ['TG', 'Togo'],
    ['TH', 'Thailand'],
    ['TJ', 'Tajikistan'],
    ['TK', 'Tokelau'],
    ['TL', 'Timor-Leste'],
    ['TM', 'Turkmenistan'],
    ['TN', 'Tunisia'],
    ['TO', 'Tonga'],
    ['TR', 'Türkiye'],
    ['TT', 'Trinidad and Tobago'],
    ['TV', 'Tuvalu'],
    ['TW', 'Taiwan, Province of China'],
    ['TZ', 'Tanzania, United Republic of'],
    ['UA', 'Ukraine'],
    ['UG', 'Uganda'],
    ['UK', 'United Kingdom'],
    ['UM', 'United States Minor Outlying Islands'],
    ['US', 'United States of America'],
    ['UY', 'Uruguay'],
    ['UZ', 'Uzbekistan'],
    ['VA', 'Holy See'],
    ['VC', 'Saint Vincent and the Grenadines'],
    ['VE', 'Venezuela, Bolivarian Republic of'],
    ['VG', 'Virgin Islands (British)'],
    ['VI', 'Virgin Islands (U.S.)'],
    ['VN', 'Viet Nam'],
    ['VU', 'Vanuatu'],
    ['WF', 'Wallis and Futuna'],
    ['WS', 'Samoa'],
    ['YE', 'Yemen'],
    ['YT', 'Mayotte'],
    ['ZA', 'South Africa'],
    ['ZM', 'Zambia'],
    ['ZW', 'Zimbabwe'],
]);
/**
 * ISO-3166 US state ISO codes
 * @see https://en.wikipedia.org/wiki/ISO_3166-2:US
 * */
const usStates = new Map([
    ['US-AL', 'Alabama'],
    ['US-AK', 'Alaska'],
    ['US-AZ', 'Arizona'],
    ['US-AR', 'Arkansas'],
    ['US-CA', 'California'],
    ['US-CO', 'Colorado'],
    ['US-CT', 'Connecticut'],
    ['US-DE', 'Delaware'],
    ['US-FL', 'Florida'],
    ['US-GA', 'Georgia'],
    ['US-HI', 'Hawaii'],
    ['US-ID', 'Idaho'],
    ['US-IL', 'Illinois'],
    ['US-IN', 'Indiana'],
    ['US-IA', 'Iowa'],
    ['US-KS', 'Kansas'],
    ['US-KY', 'Kentucky'],
    ['US-LA', 'Louisiana'],
    ['US-ME', 'Maine'],
    ['US-MD', 'Maryland'],
    ['US-MA', 'Massachusetts'],
    ['US-MI', 'Michigan'],
    ['US-MN', 'Minnesota'],
    ['US-MS', 'Mississippi'],
    ['US-MO', 'Missouri'],
    ['US-MT', 'Montana'],
    ['US-NE', 'Nebraska'],
    ['US-NV', 'Nevada'],
    ['US-NH', 'New Hampshire'],
    ['US-NJ', 'New Jersey'],
    ['US-NM', 'New Mexico'],
    ['US-NY', 'New York'],
    ['US-NC', 'North Carolina'],
    ['US-ND', 'North Dakota'],
    ['US-OH', 'Ohio'],
    ['US-OK', 'Oklahoma'],
    ['US-OR', 'Oregon'],
    ['US-PA', 'Pennsylvania'],
    ['US-RI', 'Rhode Island'],
    ['US-SC', 'South Carolina'],
    ['US-SD', 'South Dakota'],
    ['US-TN', 'Tennessee'],
    ['US-TX', 'Texas'],
    ['US-UT', 'Utah'],
    ['US-VT', 'Vermont'],
    ['US-VA', 'Virginia'],
    ['US-WA', 'Washington'],
    ['US-WV', 'West Virginia'],
    ['US-WI', 'Wisconsin'],
    ['US-WY', 'Wyoming'],
    ['US-DC', 'District of Columbia'],
    ['US-AS', 'American Samoa'],
    ['US-GU', 'Guam'],
    ['US-MP', 'Northern Mariana Islands'],
    ['US-PR', 'Puerto Rico'],
    ['US-UM', 'United States Minor Outlying Islands'],
    ['US-VI', 'Virgin Islands, U.S.'],
]);
new Set([...isoCountries.keys(), ...usStates.keys()]);
const parseCache = new Map();
const parseRegions = (regionString) => {
    const include = new Set();
    const exclude = new Set();
    if (regionString) {
        const [a = '', b = ''] = regionString.split('|');
        for (const item of a.split(',')) {
            if (item) {
                include.add(item);
            }
        }
        for (const item of b.split(',')) {
            if (item) {
                exclude.add(item);
            }
        }
    }
    return { include, exclude };
};
const doesGeoRequestMatchList = (requestCountry, requestRegion, isEUCountry, geoRegions) => {
    if (!requestCountry || !geoRegions) {
        return true;
    }
    let parsed = parseCache.get(geoRegions);
    if (!parsed) {
        parsed = parseRegions(geoRegions);
        parseCache.set(geoRegions, parsed);
    }
    const entries = [requestCountry, `${requestCountry}-${requestRegion}`];
    if (isEUCountry) {
        entries.push('EU');
    }
    if (parsed.include.size &&
        entries.every((entry) => !parsed.include.has(entry))) {
        return false;
    }
    if (parsed.exclude.size &&
        entries.some((entry) => parsed.exclude.has(entry))) {
        return false;
    }
    return true;
};

// eslint-disable-next-line @nx/enforce-module-boundaries
let edgeTagSettings;
const initSettings = (destination, options) => {
    if (!edgeTagSettings) {
        edgeTagSettings = {};
    }
    edgeTagSettings[destination] = {
        destination,
        initialized: false,
        stubs: [],
        browserPackages: [],
        channels: new Map(),
        geoCountry: null,
        geoRegion: null,
        isEURequest: false,
        consentSetting: {
            enabled: false,
            channels: {},
        },
        ...options,
    };
};
const setSetting = (destination, options) => {
    if (!edgeTagSettings) {
        return;
    }
    if (!destination) {
        Object.keys(edgeTagSettings).forEach((key) => {
            edgeTagSettings[key] = {
                ...edgeTagSettings[key],
                ...options,
            };
        });
        return;
    }
    edgeTagSettings[destination] = {
        ...edgeTagSettings[destination],
        ...options,
    };
};
const getSetting = (destination, key) => {
    var _a;
    return (_a = edgeTagSettings === null || edgeTagSettings === void 0 ? void 0 : edgeTagSettings[destination]) === null || _a === void 0 ? void 0 : _a[key];
};
const getInstances = () => {
    return Object.keys(edgeTagSettings || {});
};
const addChannel = (destination, pkg, tagName) => upsert(getSetting(destination, 'channels'), pkg, (names) => names.add(tagName), () => new Set());
const getProviderVariables = (destination, packageId) => {
    const setting = getSetting(destination, 'manifest');
    if (!setting) {
        return [];
    }
    return (setting
        .filter((pkg) => pkg.package === packageId)
        .map((pkg) => ({
        tagName: pkg.tagName,
        geoRegions: pkg.geoRegions || null,
        variableSet: pkg.variables || {},
    })) || []);
};

const getUserAgent = () => {
    try {
        const nav = navigator;
        return nav.userAgent;
    }
    catch {
        return '';
    }
};
const getReferrer = (destination) => {
    let referrer = '';
    try {
        const referrerUrl = new URL(document.referrer);
        const pageUrl = new URL(getPageUrl(destination));
        if (referrerUrl.host !== pageUrl.host) {
            referrer = referrerUrl.href;
        }
        return referrer;
    }
    catch (error) {
        return referrer;
    }
};
const getPageUrl = (destination) => {
    const config = getSetting(destination, 'config');
    let pageUrl = (config === null || config === void 0 ? void 0 : config.pageUrl) || '';
    try {
        // we need to leave this one in for existing Custom pixel customers
        if (window.edgetagData && window.edgetagData['pageUrl']) {
            return window.edgetagData['pageUrl'];
        }
        if (!pageUrl) {
            pageUrl = window.location.href;
        }
    }
    catch {
        // do nothing
    }
    return pageUrl;
};
const getSearch = (destination) => {
    try {
        return new URL(getPageUrl(destination)).search;
    }
    catch {
        return '';
    }
};
const getLocale = () => {
    try {
        return navigator.language;
    }
    catch {
        return '';
    }
};
const getPageTitle = () => {
    try {
        return document.title;
    }
    catch {
        return '';
    }
};
const areEqual = (a, b) => {
    if (typeof a !== typeof b ||
        Array.isArray(a) !== Array.isArray(b) ||
        isNaN(a) !== isNaN(b)) {
        return false;
    }
    if (typeof a !== 'object' || a === null) {
        return a === b;
    }
    const as = Object.keys(a);
    const bs = Object.keys(b);
    if (as.length !== bs.length)
        return false;
    for (const key of as) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!(key in b)) {
            return false;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!areEqual(a[key], b[key])) {
            return false;
        }
    }
    return true;
};

const tagStorage = 'edgeTag';
const consentKey = 'consent';
const consentCategoriesKey = 'consentCategories';
const keyPrefix = `_worker`;
const cookieKey = 'tag_user_id';
const fallbackSessionKey = 'fallback_tag_user_id';
const storageIdKey = 'storageId';

const encodeString = (name) => {
    if (typeof btoa === 'undefined') {
        return Buffer.from(name).toString('base64');
    }
    return btoa(name);
};
const getBasicRandomNumber = () => {
    return parseInt((Math.random() * 10000000000).toString(), 10);
};
const generateUUID = () => {
    let id = '';
    try {
        id = crypto.randomUUID();
        if (!id) {
            const array = new Uint32Array(20);
            const numbers = crypto.getRandomValues(array);
            for (let i = 0; i < 5; i++) {
                const y = i * 3;
                if (i !== 0) {
                    id += '-';
                }
                const sum = numbers[y + 1] + numbers[y + 2] + numbers[y + 3];
                id += sum.toString();
            }
        }
    }
    catch {
        id = `${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}-${getBasicRandomNumber()}`;
        console.log('[EdgeTag] Crypto module not found');
    }
    return id;
};
const generateEventId = (name) => {
    let time = Date.now().toString();
    if (typeof performance !== 'undefined' &&
        typeof performance.now === 'function') {
        const perf = performance.now();
        if (perf) {
            time = perf.toFixed(4);
        }
    }
    return `${encodeString(name)}-${generateUUID()}-${time}`;
};

const getCookieValue = (key) => {
    var _a;
    try {
        if (!document || !document.cookie) {
            return '';
        }
        const cookies = parseCookies(document.cookie);
        return (_a = cookies[key]) !== null && _a !== void 0 ? _a : '';
    }
    catch {
        return '';
    }
};
const parseCookies = (cookie) => {
    return Object.fromEntries(cookie
        .split(/;\s+/)
        .map((r) => r.split('=').map((str) => str.trim()))
        .map(([cookieKey, ...cookieValues]) => {
        const cookieValue = cookieValues.join('=');
        if (!cookieKey) {
            return [];
        }
        let decodedValue = '';
        if (cookieValue) {
            try {
                decodedValue = decodeURIComponent(cookieValue);
            }
            catch (e) {
                console.log(`Unable to decode cookie ${cookieKey}: ${e}`);
                decodedValue = cookieValue;
            }
        }
        return [cookieKey, decodedValue];
    }));
};

const canLog = () => {
    try {
        return localStorage.getItem('edgeTagDebug') === '1';
    }
    catch {
        return false;
    }
};
const prefix = `[EdgeTag]`;
const logger = {
    log: (...args) => {
        if (canLog()) {
            console.log(prefix, ...args);
        }
    },
    error: (...args) => {
        if (canLog()) {
            console.error(prefix, ...args);
        }
    },
    info: (...args) => {
        if (canLog()) {
            console.info(prefix, ...args);
        }
    },
    trace: (...args) => {
        if (canLog()) {
            console.trace(prefix, ...args);
        }
    },
};

const initKey = `${keyPrefix}StoreMultiple`;
const saveDataPerKey = (destination, persistType, provider, value, key) => {
    const storage = getData$1(destination, persistType);
    if (!storage['data']) {
        storage['data'] = {};
    }
    if (!storage['data'][provider]) {
        storage['data'][provider] = {};
    }
    storage['data'][provider][key] = value;
    saveData(destination, persistType, storage);
};
const saveKV = (destination, data) => {
    const currentSession = getData$1(destination, 'session');
    if (!currentSession['kv']) {
        currentSession['kv'] = {};
    }
    currentSession['kv'] = {
        ...currentSession['kv'],
        ...data,
    };
    saveData(destination, 'session', currentSession);
};
const savePerKey = (destination, persistType, provider, value, key) => {
    const storage = getData$1(destination, persistType);
    if (!storage[provider]) {
        storage[provider] = {};
    }
    storage[provider][key] = value;
    saveData(destination, persistType, storage);
};
const getDataPerKey = (destination, persistType, provider, key) => {
    const storage = getData$1(destination, persistType);
    if (!storage[provider]) {
        return undefined;
    }
    return storage[provider][key];
};
const saveData = (destination, persistType, value, key = initKey) => {
    if (persistType === 'session') {
        const data = getSession(key);
        data[destination] = value;
        saveSession(data, key);
        return;
    }
    const data = getLocal(key);
    data[destination] = value;
    saveLocal(data, key);
};
const getData$1 = (destination, persistType, key = initKey) => {
    let data;
    if (persistType === 'session') {
        data = getSession(key);
    }
    else {
        data = getLocal(key);
    }
    return (data === null || data === void 0 ? void 0 : data[destination]) || {};
};
const saveLocal = (value, key) => {
    try {
        if (!localStorage) {
            return;
        }
        localStorage.setItem(key, JSON.stringify(value));
    }
    catch {
        logger.log('Local storage not supported.');
    }
};
const getLocal = (key) => {
    try {
        if (!localStorage) {
            return {};
        }
        const data = localStorage.getItem(key);
        if (!data) {
            return {};
        }
        return JSON.parse(data) || {};
    }
    catch {
        return {};
    }
};
const saveSession = (value, key) => {
    try {
        if (!sessionStorage) {
            return;
        }
        sessionStorage.setItem(key, JSON.stringify(value));
    }
    catch {
        logger.log('Session storage not supported.');
    }
};
const getSession = (key) => {
    try {
        if (!sessionStorage) {
            return {};
        }
        const data = sessionStorage.getItem(key);
        if (!data) {
            return {};
        }
        return JSON.parse(data) || {};
    }
    catch {
        return {};
    }
};

const getUserId$1 = (destination) => {
    const userId = getSetting(destination, 'userId');
    if (userId) {
        return userId;
    }
    return getCookieValue(cookieKey);
};
const handleGetUserId = (options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        return getUserId$1(options.destination);
    }
    const instances = getInstances();
    if (instances.length > 1) {
        logger.error('Multiple instances detected! Please provide a destination.');
        return '';
    }
    return getUserId$1(instances[0]);
};

const beacon = (url, payload) => {
    try {
        let blob;
        if (payload) {
            blob = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        }
        return navigator.sendBeacon(url, blob);
    }
    catch (e) {
        return Promise.reject(new Error('Beacon not supported.'));
    }
};
const ajax = (destination, method, url, payload) => fetch(url, {
    method,
    headers: {
        'Content-type': 'application/json; charset=utf-8',
        Accept: 'application/json; charset=utf-8',
        EdgeTagUserId: getUserId$1(destination),
    },
    body: JSON.stringify(payload),
    credentials: 'include',
})
    .then((response) => response
    .json()
    .then((data) => ({ status: response.status, body: data })))
    .then(({ status, body }) => {
    if (status < 200 || status >= 300) {
        throw new Error(`Request failed with code ${status}: ${JSON.stringify(body)}`);
    }
    return Promise.resolve(body);
});
const getStandardPayload = (destination, payload) => {
    const data = {
        pageUrl: getPageUrl(destination),
        pageTitle: getPageTitle(),
        userAgent: getUserAgent(),
        referrer: getReferrer(destination),
        search: getSearch(destination),
        locale: getLocale(),
        sdkVersion: "1.22.2" ,
        ...(payload || {}),
    };
    let storage = {};
    const session = getData$1(destination, 'session');
    if (session) {
        storage = {
            ...storage,
            ...session,
        };
    }
    const local = getData$1(destination, 'local');
    if (local) {
        storage = {
            ...storage,
            ...local,
        };
    }
    data.storage = storage;
    return data;
};
async function postRequest(url, data, options) {
    if (!url) {
        return Promise.reject(new Error('URL is empty.'));
    }
    const parsedUrl = new URL(url);
    const destination = parsedUrl.origin;
    const payload = getStandardPayload(destination, data);
    if (options && options.method === 'beacon') {
        return Promise.resolve(beacon(url, payload));
    }
    return await ajax(destination, 'POST', url, payload);
}
async function getRequest(url, options) {
    if (!url) {
        return Promise.reject(new Error('URL is empty.'));
    }
    if (options && options.method === 'beacon') {
        return {
            result: Promise.resolve(beacon(url)),
        };
    }
    const parsedUrl = new URL(url);
    const destination = parsedUrl.origin;
    return await ajax(destination, 'GET', url);
}

const generateUrl = (destination, path) => {
    if (!destination) {
        logger.log('URL is not valid');
        return '';
    }
    return `${destination}${path}`;
};
const getTagURL = (destination, eventName, options) => {
    const parsedUrl = new URL(generateUrl(destination, '/tag'));
    if (options === null || options === void 0 ? void 0 : options.sync) {
        parsedUrl.searchParams.set('sync', 'true');
    }
    if (eventName) {
        parsedUrl.searchParams.set('name', eventName);
    }
    return parsedUrl.toString();
};
const getInitURL = (destination) => {
    return generateUrl(destination, '/init');
};
const getConsentURL = (destination) => {
    return generateUrl(destination, '/consent');
};
const getUserURL = (destination) => {
    return generateUrl(destination, '/user');
};
const getDataURL = (destination) => {
    return generateUrl(destination, `/data`);
};
const getGetDataURL = (destination, keys) => {
    return generateUrl(destination, `/data?keys=${encodeURIComponent(keys.join(','))}`);
};
const getKeysURL = (destination) => {
    return generateUrl(destination, `/keys`);
};

const getConsent$1 = (destination) => {
    const storageConsent = getDataPerKey(destination, 'local', tagStorage, consentKey);
    if (storageConsent) {
        return storageConsent;
    }
    return getSetting(destination, 'consent');
};
const getConsentCategories = (destination) => {
    const storageConsentCategories = getDataPerKey(destination, 'local', tagStorage, consentCategoriesKey);
    if (storageConsentCategories) {
        return storageConsentCategories;
    }
    return getSetting(destination, 'consentCategories');
};

const processStubs = (destination) => {
    try {
        const stubs = getSetting(destination, 'stubs');
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        stubs.forEach((stub) => api[stub.name](...(stub.arguments || [])));
        setSetting(destination, {
            stubs: [],
        });
    }
    catch (e) {
        logger.error(e);
    }
};
const addStub = (destination, stub) => {
    const otherStubs = getSetting(destination, 'stubs') || [];
    setSetting(destination, {
        stubs: [...otherStubs, stub],
    });
};

const preparePayloadWithConversion = (payloadData, currencySettings) => {
    const currency = payloadData['currency'];
    const value = parseFloat(payloadData['value']);
    if (!currency || !currencySettings) {
        return null;
    }
    const conversion = currencySettings.rates.find((rate) => rate.from === currency);
    if (!conversion) {
        return null;
    }
    payloadData['currency'] = conversion.to;
    if (value) {
        payloadData['value'] = parseFloat((value * conversion.value).toFixed(3));
    }
    if ('contents' in payloadData && Array.isArray(payloadData['contents'])) {
        for (const content of payloadData['contents']) {
            if ('item_price' in content) {
                content.item_price = parseFloat((content.item_price * conversion.value).toFixed(3));
            }
        }
    }
    return {
        providers: currencySettings.providers,
        payload: payloadData,
    };
};

const processGetData = (destination, keys, callback) => {
    getRequest(getGetDataURL(destination, keys))
        .then((result) => {
        callback((result === null || result === void 0 ? void 0 : result.result) || {});
    })
        .catch(logger.error);
};
const handleGetData = (keys, callback, options) => {
    if (!keys || keys.length === 0) {
        logger.error('Provide keys for get data API.');
        return;
    }
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processGetData(options.destination, keys, callback);
        return;
    }
    const instances = getInstances();
    if (instances.length > 1) {
        logger.error('Multiple instances found! Please provide destination.');
        callback({});
        return;
    }
    processGetData(instances[0], keys, callback);
};

const sendTag = (destination, { eventName, eventId, data, providerData, providers, options }) => {
    const payload = {
        eventName,
        eventId,
        timestamp: Date.now(),
        data,
        providerData,
    };
    if (providers) {
        payload.providers = providers;
    }
    postRequest(getTagURL(destination, eventName, options), payload, options).catch(logger.error);
};
const processTag = (destination, eventName, data = {}, providers, options) => {
    var _a, _b;
    if (!getSetting(destination, 'initialized')) {
        addStub(destination, {
            name: 'tag',
            arguments: [eventName, data, providers, options],
        });
        return;
    }
    let eventId = data['eventId'];
    if (!eventId) {
        eventId = generateEventId(eventName);
    }
    const providerPackages = getSetting(destination, 'browserPackages');
    const configuredTags = getSetting(destination, 'channels');
    const skipZeroPurchaseEvent = getSetting(destination, 'skipZeroPurchaseEvent') || false;
    const requestCountry = getSetting(destination, 'geoCountry') || null;
    const requestRegion = getSetting(destination, 'geoRegion') || null;
    const isEURequest = getSetting(destination, 'isEURequest') || false;
    const sessionId = getSetting(destination, 'sessionId');
    const userId = getUserId$1(destination);
    const providerData = {};
    const consentChannel = getConsent$1(destination);
    const consentCategory = getConsentCategories(destination);
    const consentSettings = getSetting(destination, 'consentSetting');
    const userConsent = { consentChannel, consentCategory, consentSettings };
    if (skipZeroPurchaseEvent && isZeroPurchaseEvent({ eventName, data })) {
        return;
    }
    const conversion = preparePayloadWithConversion(JSON.parse(JSON.stringify(data)), getSetting(destination, 'currency'));
    for (const pkg of providerPackages) {
        if (!pkg || !pkg.name || !pkg.tag) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            logger.log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(destination, pkg.name);
        const result = {};
        const executionContext = new Map();
        for (const variable of variables) {
            if (!isProviderInstanceAllowed(providers, pkg.name, variable.tagName)) {
                logger.log(`Provider instance is not allowed (${pkg.name}: ${variable.tagName})`);
                continue;
            }
            if (!hasUserConsent(userConsent, pkg.name, variable.tagName)) {
                logger.log(`Consent is missing (${pkg.name}: ${variable.tagName})`);
                continue;
            }
            if (!doesGeoRequestMatchList(requestCountry, requestRegion, isEURequest, variable.geoRegions)) {
                logger.log('GEO request region does not match the filter, skiping');
                continue;
            }
            const payload = ((_a = conversion === null || conversion === void 0 ? void 0 : conversion.providers) === null || _a === void 0 ? void 0 : _a.length) === 0 ||
                ((_b = conversion === null || conversion === void 0 ? void 0 : conversion.providers) === null || _b === void 0 ? void 0 : _b.includes(pkg.name))
                ? conversion.payload
                : data;
            result[variable.tagName] = pkg.tag({
                userId,
                sessionId,
                eventName,
                eventId,
                data: JSON.parse(JSON.stringify(payload)),
                sendTag: sendTag.bind(null, destination),
                getEdgeData: processGetData.bind(null, destination),
                manifestVariables: variable.variableSet,
                executionContext,
                destination,
            });
        }
        providerData[pkg.name] = result;
    }
    if (!hasAllowedManifestTags(configuredTags, userConsent, providers)) {
        return;
    }
    sendTag(destination, {
        eventName,
        eventId,
        data,
        providerData,
        providers,
        options,
    });
};
const handleTag = (eventName, data = {}, providers, options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processTag(options.destination, eventName, data, providers, options);
        return;
    }
    getInstances().forEach((instance) => {
        processTag(instance, eventName, data, providers, options);
    });
};
const hasAllowedManifestTags = (tags, consent, providersConfig) => {
    for (const [pkg, tagNames] of tags) {
        for (const tagName of tagNames) {
            if (hasUserConsent(consent, pkg, tagName) &&
                isProviderInstanceAllowed(providersConfig, pkg, tagName)) {
                return true;
            }
        }
    }
    return false;
};

const processData = (destination, data, providers, options) => {
    saveKV(destination, data);
    const providerPackages = getSetting(destination, 'browserPackages');
    const configuredTags = getSetting(destination, 'channels');
    const userId = getUserId$1(destination);
    const requestCountry = getSetting(destination, 'geoCountry') || null;
    const requestRegion = getSetting(destination, 'geoRegion') || null;
    const isEURequest = getSetting(destination, 'isEURequest') || false;
    const consentChannel = getConsent$1(destination);
    const consentCategory = getConsentCategories(destination);
    const consentSettings = getSetting(destination, 'consentSetting');
    const userConsent = { consentChannel, consentCategory, consentSettings };
    for (const pkg of providerPackages) {
        if (!pkg || !pkg.user || !pkg.name) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            logger.log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(destination, pkg.name);
        for (const variable of variables) {
            if (!isProviderInstanceAllowed(providers, pkg.name, variable.tagName)) {
                logger.log(`Data not allowed for ${pkg.name} (${variable.tagName})`);
                continue;
            }
            if (!hasUserConsent(userConsent, pkg.name, variable.tagName)) {
                logger.log(`Consent is missing for ${pkg.name} (${variable.tagName})`);
                continue;
            }
            if (!doesGeoRequestMatchList(requestCountry, requestRegion, isEURequest, variable.geoRegions)) {
                logger.log(`GEO request region does not match list, skipping`);
                continue;
            }
            pkg.user({
                userId,
                data,
                manifestVariables: variable.variableSet,
            });
        }
    }
    postRequest(getDataURL(destination), { data, providers }, options).catch(logger.error);
};
const handleData = (data, providers, options) => {
    if (!data || Object.keys(data).length === 0) {
        logger.error('Provide data for data API.');
        return;
    }
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processData(options.destination, data, providers, options);
        return;
    }
    getInstances().forEach((destination) => {
        processData(destination, data, providers, options);
    });
};

const handleConsent = (consent, consentCategories, options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processConsent(options.destination, consent, consentCategories, options);
        return;
    }
    getInstances().forEach((destination) => {
        processConsent(destination, consent, consentCategories, options);
    });
};
const saveConsent = (destination, consent, consentCategories) => {
    setSetting(destination, {
        consent,
        consentCategories,
    });
    savePerKey(destination, 'local', tagStorage, consent, consentKey);
    savePerKey(destination, 'local', tagStorage, consentCategories, consentCategoriesKey);
};
const processConsent = (destination, consent, consentCategories, options) => {
    const existingConsent = getConsent$1(destination);
    const existingConsentCategories = getConsentCategories(destination);
    if (areEqual(existingConsent, consent) &&
        areEqual(existingConsentCategories, consentCategories)) {
        return;
    }
    if (!getSetting(destination, 'initialized')) {
        addStub(destination, {
            name: 'consent',
            arguments: [consent, consentCategories, options],
        });
        return;
    }
    const payload = {
        consentString: consent,
        consentCategories: { ...consentCategories, necessary: true },
    };
    saveConsent(destination, consent, consentCategories);
    if (!(options === null || options === void 0 ? void 0 : options.localSave)) {
        postRequest(getConsentURL(destination), payload).catch(logger.error);
    }
    const userId = getUserId$1(destination);
    const providerPackages = getSetting(destination, 'browserPackages');
    const executionContext = new Map();
    const requestCountry = getSetting(destination, 'geoCountry') || null;
    const requestRegion = getSetting(destination, 'geoRegion') || null;
    const isEURequest = getSetting(destination, 'isEURequest') || false;
    const consentSettings = getSetting(destination, 'consentSetting');
    /* Calling Init for all provider instances based on consent check */
    for (const pkg of providerPackages) {
        if (!pkg || !pkg.name || !pkg.init) {
            continue;
        }
        const variables = getProviderVariables(destination, pkg.name);
        for (const variable of variables) {
            const hasConsent = hasUserConsent({
                consentChannel: consent,
                consentCategory: consentCategories,
                consentSettings,
            }, pkg.name, variable.tagName);
            if (!hasConsent) {
                continue;
            }
            if (!doesGeoRequestMatchList(requestCountry, requestRegion, isEURequest, variable.geoRegions)) {
                continue;
            }
            pkg.init({
                userId,
                isNewUser: false,
                baseUrl: destination,
                manifest: {
                    tagName: variable.tagName,
                    variables: variable.variableSet,
                    package: pkg.name,
                    geoRegions: variable.geoRegions,
                },
                sendTag: sendTag.bind(null, destination),
                sendEdgeData: processData.bind(null, destination),
                getEdgeData: processGetData.bind(null, destination),
                keyName: `${keyPrefix}Store`,
                executionContext,
                session: null,
                destination,
                consentData: {
                    consent,
                    categories: { ...consentCategories, necessary: true },
                    consentSettings,
                },
            });
        }
    }
    try {
        window.dispatchEvent(new CustomEvent('edgetag-consent', {
            detail: {
                destination,
                oldConsent: existingConsent,
                newConsent: consent,
            },
        }));
    }
    catch {
        // do nothing
    }
    /* Calling Consent for all providers, not on instance level */
    for (const pkg of Object.values(providerPackages)) {
        if (!pkg || !pkg.name || !pkg.consent) {
            continue;
        }
        const variables = getProviderVariables(destination, pkg.name);
        pkg.consent({
            consentData: {
                consent,
                categories: {
                    ...consentCategories,
                    necessary: true,
                },
                consentSettings,
            },
            variables,
        });
    }
};

const setPreferences = (preferences) => {
    var _a;
    if (!preferences) {
        return null;
    }
    if (!preferences.edgeURL) {
        logger.error('Please provide URL for EdgeTag');
        return null;
    }
    const providersPackages = {};
    (_a = preferences.providers) === null || _a === void 0 ? void 0 : _a.forEach((provider) => {
        if (!provider.name) {
            return;
        }
        providersPackages[provider.name] = provider;
    });
    try {
        if (window && Array.isArray(window.edgetagProviders)) {
            window.edgetagProviders.forEach((provider) => {
                if (!provider.name) {
                    return;
                }
                providersPackages[provider.name] = provider;
            });
        }
    }
    catch {
        // do nothing
    }
    initSettings(preferences.edgeURL, {
        disableConsent: !!preferences.disableConsentCheck,
    });
    return providersPackages;
};

const cacheKey = `${keyPrefix}Cache`;
const identity = (v) => v;
const saveDataToEdge = (destination, key, value, provider) => {
    if (!value) {
        return;
    }
    let updatedValue = value;
    if (typeof value !== 'string') {
        try {
            updatedValue = JSON.stringify(value);
        }
        catch {
            logger.log('Error stringify value.');
            return;
        }
    }
    handleData({ [`${provider}::${key}`]: updatedValue }, undefined, {
        destination,
    });
};
const handleCaptureQuery = (destination, provider, key, persistType, map) => {
    try {
        if (!window) {
            return;
        }
    }
    catch {
        return;
    }
    const params = new URLSearchParams(getSearch(destination));
    if (!params || !params.get(key)) {
        return;
    }
    const data = (map !== null && map !== void 0 ? map : identity)(params.get(key));
    if (!data) {
        return;
    }
    if (persistType === 'edge') {
        saveDataToEdge(destination, key, data, provider);
        return;
    }
    saveDataPerKey(destination, persistType, provider, data, key);
};
const getFromCache = (destination, persistType, provider, key) => {
    var _a;
    const type = persistType === 'edge' ? 'local' : persistType;
    const cache = getData$1(destination, type, cacheKey);
    return (_a = cache[provider]) === null || _a === void 0 ? void 0 : _a[key];
};
const saveToCache = (destination, persistType, provider, key, value) => {
    const type = persistType === 'edge' ? 'local' : persistType;
    const cache = getData$1(destination, type, cacheKey);
    if (!cache[provider]) {
        cache[provider] = { [key]: value };
    }
    else {
        cache[provider][key] = value;
    }
    saveData(destination, type, cache, cacheKey);
};
const handleCaptureStorage = (destination, provider, key, persistType, location, map) => {
    let data;
    try {
        switch (location) {
            case 'cookie': {
                data = (map !== null && map !== void 0 ? map : identity)(getCookieValue(key));
                break;
            }
            case 'local': {
                data = (map !== null && map !== void 0 ? map : identity)(localStorage.getItem(key));
                break;
            }
            case 'session': {
                data = (map !== null && map !== void 0 ? map : identity)(sessionStorage.getItem(key));
            }
        }
    }
    catch {
        return;
    }
    if (!data) {
        return;
    }
    const cachedKey = `${getUserId$1(destination)}/${key}`;
    const cachedValue = getFromCache(destination, persistType, provider, cachedKey);
    if (persistType === 'edge' && cachedValue !== data) {
        saveDataToEdge(destination, key, data, provider);
        saveToCache(destination, persistType, provider, cachedKey, data);
        return;
    }
    saveDataPerKey(destination, persistType, provider, data, key);
};
const handleCapture = (destination, provider, params, capture) => {
    params.forEach((param) => {
        switch (param.type) {
            case 'query': {
                handleCaptureQuery(destination, provider, param.key, param.persist, capture === null || capture === void 0 ? void 0 : capture.bind(null, param));
                break;
            }
            case 'storage': {
                handleCaptureStorage(destination, provider, param.key, param.persist, param.location, capture === null || capture === void 0 ? void 0 : capture.bind(null, param));
                break;
            }
        }
    });
};

const keyName = `${keyPrefix}Store`;
const handleManifest = (destination, response) => {
    const providerPackages = getSetting(destination, 'browserPackages');
    const userId = getUserId$1(destination);
    const executionContext = new Map();
    const manifest = response.result;
    const consentChannel = getConsent$1(destination);
    const consentCategory = getConsentCategories(destination);
    const consentSettings = getSetting(destination, 'consentSetting');
    const userConsent = { consentChannel, consentCategory, consentSettings };
    manifest.forEach((provider) => {
        addChannel(destination, provider.package, provider.tagName);
        const pkg = providerPackages.find((pkg) => pkg.name === provider.package);
        if (provider.rules) {
            Object.entries(provider.rules).forEach(([name, recipe]) => {
                switch (name) {
                    case 'capture': {
                        handleCapture(destination, provider.package, recipe, pkg === null || pkg === void 0 ? void 0 : pkg.capture);
                        return;
                    }
                }
            });
        }
        if (pkg && pkg.name && pkg.init) {
            const hasConsent = hasUserConsent(userConsent, pkg.name, provider.tagName);
            if (hasConsent &&
                doesGeoRequestMatchList(response.geoCountry, response.geoRegion, response.isEURequest, provider.geoRegions)) {
                pkg.init({
                    userId,
                    isNewUser: !!response.isNewUser,
                    session: response.session,
                    baseUrl: destination,
                    manifest: provider,
                    sendTag: sendTag.bind(null, destination),
                    sendEdgeData: processData.bind(null, destination),
                    getEdgeData: processGetData.bind(null, destination),
                    keyName,
                    executionContext,
                    destination,
                    consentData: {
                        consent: response.consent,
                        categories: response.consentCategories,
                        consentSettings: response.consentSetting,
                    },
                });
            }
        }
    });
    setSetting(destination, {
        initialized: true,
    });
    processStubs(destination);
};

const mapData = (data) => async (callback) => {
    try {
        await callback(data);
    }
    catch (err) {
        console.error(err);
    }
};
const callbacks = new Set();
const resolved = new Set();
const onReady = async (data) => {
    const callbackData = {
        destination: data.destination,
        userId: data.userId,
        sessionId: data.session.sessionId,
        isNewUser: data.isNewUser,
        isNewSession: data.session.isNewSession,
    };
    resolved.add(callbackData);
    await Promise.all([...callbacks].map(mapData(callbackData)));
};
const handleReady = async (callback) => {
    callbacks.add(callback);
    await Promise.all([...resolved.values()].map((data) => mapData(data)(callback)));
};

const handleInit = (preferences) => {
    const browserPackages = setPreferences(preferences);
    if (!browserPackages) {
        return;
    }
    let fallbackId;
    try {
        fallbackId = preferences.fallbackUserId;
        if (!fallbackId) {
            const fallbackSessionValue = sessionStorage.getItem(fallbackSessionKey);
            if (!fallbackSessionValue) {
                const randomId = crypto.randomUUID();
                if (randomId) {
                    fallbackId = `${randomId}-${Date.now()}`;
                    sessionStorage.setItem(fallbackSessionKey, fallbackId);
                }
            }
            else {
                fallbackId = fallbackSessionValue;
            }
        }
    }
    catch {
        // do nothing
    }
    if (preferences.afterManifestEvents) {
        setSetting(preferences.edgeURL, {
            stubs: preferences.afterManifestEvents,
        });
    }
    const url = new URL(getInitURL(preferences.edgeURL));
    if (preferences.disableConsentCheck) {
        url.searchParams.set('consentDisabled', 'true');
        saveConsent(preferences.edgeURL, {
            all: true,
        }, {
            all: true,
        });
    }
    if (preferences.userId) {
        setSetting(preferences.edgeURL, { userId: preferences.userId });
        url.searchParams.set('userId', preferences.userId);
    }
    if (fallbackId) {
        url.searchParams.set('fallbackUserId', fallbackId);
    }
    let dbIndex;
    if (preferences.storageId != null) {
        dbIndex = preferences.storageId;
    }
    else {
        dbIndex = getDataPerKey(preferences.edgeURL, 'local', tagStorage, storageIdKey);
    }
    if (dbIndex != null && !isNaN(dbIndex)) {
        url.searchParams.set('storageId', dbIndex.toString());
    }
    if (preferences.sessionId) {
        url.searchParams.set('sessionId', preferences.sessionId);
    }
    url.searchParams.set('pageUrl', getPageUrl(preferences.edgeURL));
    getRequest(url.href)
        .then((result) => {
        var _a;
        if (!result) {
            logger.error('Initialization failed');
            return;
        }
        if (result.isNewUser && result.consent) {
            saveConsent(preferences.edgeURL, result.consent, result.consentCategories);
        }
        const providers = {};
        (_a = result.result) === null || _a === void 0 ? void 0 : _a.forEach((pkg) => {
            const provider = browserPackages[pkg.package];
            if (!provider) {
                return;
            }
            providers[pkg.package] = provider;
        });
        setSetting(preferences.edgeURL, {
            isNewUser: result.isNewUser,
            consent: getConsent$1(preferences.edgeURL) || result.consent,
            userId: result.userId,
            sessionId: result.session.sessionId,
            manifest: result.result,
            browserPackages: Object.values(providers),
            storageId: result.storageId,
            currency: result.currency,
            skipZeroPurchaseEvent: result.skipZeroPurchaseEvent,
            geoCountry: result.geoCountry,
            geoRegion: result.geoRegion,
            isEURequest: result.isEURequest,
            consentSetting: result.consentSetting,
        });
        if (result.storageId != null) {
            savePerKey(preferences.edgeURL, 'local', tagStorage, result.storageId, storageIdKey);
        }
        handleManifest(preferences.edgeURL, result);
        try {
            const detail = {
                destination: preferences.edgeURL,
                userId: result.userId,
                isNewUser: result.isNewUser,
                consent: result.consent,
                consentSetting: result.consentSetting,
                session: result.session,
            };
            window.dispatchEvent(new CustomEvent('edgetag-initialized', {
                detail,
            }));
            onReady(detail);
        }
        catch {
            // do nothing
        }
    })
        .catch(logger.error);
};

const processUser = (destination, key, value, providers, options) => {
    saveKV(destination, {
        [key]: value,
    });
    const providerPackages = getSetting(destination, 'browserPackages');
    const configuredTags = getSetting(destination, 'channels');
    const userId = getUserId$1(destination);
    const requestCountry = getSetting(destination, 'geoCountry') || null;
    const requestRegion = getSetting(destination, 'geoRegion') || null;
    const isEURequest = getSetting(destination, 'isEURequest') || false;
    const consentChannel = getConsent$1(destination);
    const consentCategory = getConsentCategories(destination);
    const consentSettings = getSetting(destination, 'consentSetting');
    const userConsent = { consentChannel, consentCategory, consentSettings };
    for (const pkg of providerPackages) {
        if (!pkg || !pkg.name || !pkg.user) {
            continue;
        }
        if (!configuredTags.has(pkg.name)) {
            logger.log(`Provider ${pkg.name} is not in allow list`);
            continue;
        }
        const variables = getProviderVariables(destination, pkg.name);
        for (const variable of variables) {
            if (!isProviderInstanceAllowed(providers, pkg.name, variable.tagName)) {
                logger.log(`User not allowed for ${pkg.name} (${variable.tagName})`);
                continue;
            }
            if (!hasUserConsent(userConsent, pkg.name, variable.tagName)) {
                logger.log(`User do not have consent for ${pkg.name} (${variable.tagName})`);
                continue;
            }
            if (!doesGeoRequestMatchList(requestCountry, requestRegion, isEURequest, variable.geoRegions)) {
                logger.log(`GEO request region does not match list, skipping`);
                continue;
            }
            pkg.user({
                userId,
                data: { [key]: value },
                manifestVariables: variable.variableSet,
            });
        }
    }
    postRequest(getUserURL(destination), {
        key,
        value,
        providers,
    }, options).catch(logger.error);
};
const handleUser = (key, value, providers, options) => {
    if (!key || !value) {
        logger.error('Key or Value is missing in user API.');
        return;
    }
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processUser(options.destination, key, value, providers, options);
        return;
    }
    getInstances().forEach((destination) => {
        processUser(destination, key, value, providers, options);
    });
};

const processKeys = (destination, callback) => {
    getRequest(getKeysURL(destination))
        .then((result) => {
        callback((result === null || result === void 0 ? void 0 : result.result) || []);
    })
        .catch(logger.error);
};
const handleKeys = (callback, options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processKeys(options.destination, callback);
        return;
    }
    const instances = getInstances();
    if (instances.length > 1) {
        logger.error('Multiple instances found! Please provide destination.');
        callback([]);
        return;
    }
    processKeys(instances[0], callback);
};

const processGetConsent = (destination, callback) => {
    getRequest(getConsentURL(destination))
        .then((result) => {
        // this will try to return the consent data stored in Edge
        return result === null || result === void 0 ? void 0 : result.result;
    })
        .catch(() => undefined)
        .then((result) => {
        const consent = result !== null && result !== void 0 ? result : getConsent$1(destination); // this is a default value i.e. value from local storage and memory incase Edge doesn't have consent
        if (consent) {
            callback(consent);
        }
        else {
            callback(null, new Error('Consent not found for Current User!'));
        }
    });
};
const handleGetConsent = (callback, options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processGetConsent(options.destination, callback);
        return;
    }
    const instances = getInstances();
    if (instances.length > 1) {
        callback(null, new Error('Multiple instances found! Please provide destination.'));
        return;
    }
    processGetConsent(instances[0], callback);
};

const handleIsNewUser = (options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        return getSetting(options.destination, 'isNewUser');
    }
    const instances = getInstances();
    if (instances.length > 1) {
        logger.error('Multiple instances found! Please provide destination.');
        return undefined;
    }
    return getSetting(instances[0], 'isNewUser');
};

const processConfig = (destination, config) => {
    const existingConfig = getSetting(destination, 'config');
    setSetting(destination, {
        config: {
            ...existingConfig,
            ...config,
        },
    });
};
const handleConfig = (config, options) => {
    if (options === null || options === void 0 ? void 0 : options.destination) {
        processConfig(options.destination, config);
        return;
    }
    getInstances().forEach((destination) => {
        processConfig(destination, config);
    });
};

const init = (preferences) => {
    handleInit(preferences);
};
const tag = (name, data, providers, options) => {
    handleTag(name, data, providers, options);
};
const consent = (consentChannels, consentCategories, options) => {
    handleConsent(consentChannels, consentCategories, options);
};
const user = (key, value, providers, options) => {
    handleUser(key, value, providers, options);
};
const data = (value, providers, options) => {
    handleData(value, providers, options);
};
const getData = (keys, callback, options) => {
    handleGetData(keys, callback, options);
};
const keys = (callback, options) => {
    handleKeys(callback, options);
};
const getUserId = (options) => {
    return handleGetUserId(options);
};
const getConsent = (callback, options) => {
    handleGetConsent(callback, options);
};
const isNewUser = (options) => {
    return handleIsNewUser(options);
};
const setConfig = (config, options) => {
    handleConfig(config, options);
};
const ready = (callback) => {
    handleReady(callback);
};

exports.consent = consent;
exports.data = data;
exports.getConsent = getConsent;
exports.getData = getData;
exports.getUserId = getUserId;
exports.init = init;
exports.isNewUser = isNewUser;
exports.keys = keys;
exports.ready = ready;
exports.setConfig = setConfig;
exports.tag = tag;
exports.user = user;
